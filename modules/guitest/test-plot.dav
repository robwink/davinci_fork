# test-plot.dav

# Davinci GUI test script.

verbose = 0
#debug = 1
load_module("gui")

# See 'Main' below for most API comments.

#####
#
# Support functions
#
#####

define stretch() {
	a = $1
	b = moment(a)
	c = (((a - b[1]) / (b[2]-b[1])) * 255)

	return(byte(c));
}

# Some hacky struct manipulation functions to supported integer-indexed
# struct access.  This is done to emulate an array of structs, sort of
# like a Perl hash.  It's inefficient but that's ok.

define my_set_struct(s) {

  position = $1
  value = $2

  if (HasValue(get_struct(s, sprintf("%d", position)))) {
    remove_struct(s, sprintf("%d", position))
  }

  add_struct(s, name=sprintf("%d", position), value)

  return(0)

}

define my_get_struct(s) {

  position = $1

  if (HasValue(get_struct(s, sprintf("%d", position)))) {
    return(get_struct(s, sprintf("%d", position)))
  }

#  printf("WARNING: attempted to access non-existant struct member '%s'\n", \
#	position)

  return(-1)

}

define myplot(pd) {

#  dump(pd, depth = 6)
#  return(0)

  # Plot an XY average for all stored plots.
  xplotEvalString = "xplot("
  needComma = 0
  for (i = 1; i <= pd.numColors; i = i + 1) {
    if (HasValue(get_struct(pd.data, sprintf("%d", i)))) {
      if (needComma == 1) {
        xplotEvalString += ", "
      }
      lineLabel = gui.get(pd.labelFields[i]).value
      xplotEvalString += \
        sprintf("avg(get_struct(pd.data, \"%s\"), axis=XY), \"title '%s' with lines lt %d\"", \
          sprintf("%d", i), lineLabel, i)
      needComma = 1
    }
  }
  xplotEvalString += ", axis = Z)"
#  printf("plotting: %s\n", xplotEvalString)
  eval(xplotEvalString)

  return(0)

}

define dialog() {

  msg = $2
  printf("%s\n", msg)
  return(-1)

}

# dialog() displays a very basic message dialog box.  In the future
# this will use the Motif XmErrorDialog widget.  This dialog must be
# closed manually.

define _dialog() {

  msg = $1
  title = "Error"

  if ($ARGC == 2) {
    title = $2
  }

  dTop = gui.create("topLevelShell", name = title)

  errLabel = gui.create("label", dTop, { labelString = msg })

  gui.realize(dTop)

  return(dTop)

}

# showVicar() displays a VICAR widget with the specified filename.
# Returns the widget ID, or -1 on error.

define showVicar(widgetMap) {

  fileName = $1

  # Pop up a dialog informing the user that the file is loading, since this
  # might take a few seconds.

  titleString = sprintf("Loading %s..", fileName)
  msgString = sprintf("Loading %s, please wait..", fileName)
  dialog(msgString, titleString)

  data = load_pds(fileName)

  if (dim(data.qube.data)[3] != 10) {
    dialog("Only 10-band cubes are supported.")
    return(-1)
  }

  titleString2 = sprintf("Stretching %s..", fileName)
  dialog(titleString2, titleString)

  data = data.qube.data
  data[where data < 0] = 0
  dpyData = cat(stretch(data[,,3]), stretch(data[,,5]), stretch(data[,,7]),z)
  dpyData = bsq(dpyData)

  vtop = gui.create("topLevelShell", name=fileName)
  vicar = gui.create("vicar", vtop, { image = dpyData })

  gui.set(vicar, { inputMode = "MODE_SELECT" })
  gui.realize(vtop)

  # Save this VICAR widget's details for use later.

  newVicar = { vicarWidgetId = vicar, origData = data, dpyData = dpyData, fileName = fileName }
  add_struct(widgetMap, name = sprintf("%d", vicar), value = newVicar)

  # Add selection callback.

  gui.addcallback(vicar, "select", sprintf("vicarSelectionCallback(%d)", vicar))

  return(vtop)

}

#####
#
# Callback functions
#
#####

define fileSelectCallback() {

  global(top)
  global(plot)
  global(map)

  self = $1
  action = $2

  if (action == "cancel") {
    gui.destroy(top)
    return(0)
  }

  # User selected a file; get the filename and open a VICAR widget.
  # The filename is stored on a widget property, which can be
  # obtained via gui.get().  Because gui.get() returns a struct, you
  # can obtain individual resources in a pseudo-object-oriented way.

  fileName = gui.get(self).dirSpec
  showVicar(widgetMap = map, fileName)

  # Create a radio box so the user can select the plot color they wish to
  # use.

  plotBoxTop = gui.create("topLevelShell", name = "Plot Color")
  plotBoxPane = gui.create("panedWindow", plotBoxTop)
  plotBoxLabel = gui.create("label", plotBoxPane, { labelString = "Plot Controls" })
  plotBoxRC = gui.create("rowColumn", plotBoxPane, \
    { numColumns = 4, packing = "PACK_COLUMN", radioBehavior = "true", adjustLast = "false" })

  for (i = 1; i <= plot.numColors; i = i + 1) {
    if (i == 1) {
      plot.colorButtons[i] = gui.create("toggleButton", plotBoxRC, \
        { labelString = plot.colors[,i], set = "true" })
    } else {
      plot.colorButtons[i] = gui.create("toggleButton", plotBoxRC, \
        { labelString = plot.colors[,i] })
    }
    gui.addcallback(plot.colorButtons[i], "arm", sprintf("plotColorButtonCallback(%d)", plot.colorButtons[i]))
  }

  for (i = 1; i <= plot.numColors; i = i + 1) {
    plot.deleteButtons[i] = gui.create("pushButton", plotBoxRC, \
      { labelString = "Delete" })
    gui.addcallback(plot.deleteButtons[i], "arm", sprintf("plotDeleteButtonCallback(%d)", plot.deleteButtons[i]))
  }

  for (i = 1; i <= plot.numColors; i = i + 1) {
    plot.labelFields[i] = gui.create("textField", plotBoxRC)
  }

  for (i = 1; i <= plot.numColors; i = i + 1) {
    plot.labelButtons[i] = gui.create("pushButton", plotBoxRC,  { labelString = "Change Label" })
    gui.addcallback(plot.labelButtons[i], "arm", sprintf("plotLabelButtonCallback(%d)", plot.labelButtons[i]))
  }

  gui.realize(plotBoxTop)

  # At this point, we could close the file selection window, but it's left
  # open so that new files can be opened.

  return(0)

}

define plotColorButtonCallback() {

  widget = $1

  global(plot)

  for (i = 1; i <= plot.numColors; i = i + 1) {
    if (widget == plot.colorButtons[i]) {
      plot.index = i
    }
  }

  return(0)

}

define plotDeleteButtonCallback() {

  widget = $1

  global(plot)

  for (i = 1; i <= plot.numColors; i = i + 1) {
    if (widget == plot.deleteButtons[i]) {
      remove_struct(plot.data, name = sprintf("%d", i))
      myplot(pd = plot)
    }
  }

  return(0)

}

define plotLabelButtonCallback() {

  widget = $1

  global(plot)

  for (i = 1; i <= plot.numColors; i = i + 1) {
    if (widget == plot.labelButtons[i]) {
      myplot(pd = plot)
    }
  }

  return(0)

}

define vicarSelectionCallback() {

  widget = $1

  global(plot)
  global(map)

  for (i = 1; i <= length(map); i = i + 1) {
    vicarInfo = map[i]
    if (widget == vicarInfo.vicarWidgetId) {

      selection = gui.get(vicarInfo.vicarWidgetId).selection
      x = int(selection.x)
      y = int(selection.y)
      width = int(selection.width)
      height = int(selection.height)

      # Get a cube representing the selected area.
      crop = vicarInfo.origData[x:(x + width), y:(y + height)];

      # Save the crop area for re-plotting.
      my_set_struct(s = plot.data, plot.index, crop)

      myplot(pd = plot)

    }
  }

  return(0)

}

#####
#
# Main
#
#####

# Some GNU plot stuff.

plot = struct()
plot.colors = cat("Red", "Green", "Blue", "Magenta", "Cyan", "Sienna", \
  "Orange", "Coral", axis = y)
plot.numColors = length(plot.colors)
plot.colorButtons = create(plot.numColors)
plot.deleteButtons = create(plot.numColors)
plot.labelFields = create(plot.numColors)
plot.labelButtons = create(plot.numColors)
plot.index = 1
plot.data = struct()

# Vicar data map for widget ID/data/filename mappings.

map = struct()

# All widgets are created using gui.create.  The syntax is:
#
# dvwidgetid = gui.create(widgetclass, parent, resources, name)
#
# dvwidgetid
#   An integer widget ID representing the widget created, or -1 if an error
#   occurred.  Retain the widget ID for use in other GUI functions.
#
# widgetclass
#   Xt/Motif widget class name, or a built-in abbreviation.  Most widget
#   classes have short common-sense names, but if in doubt, you can use
#   the fully widget class name.  For example, "list" and "xmListWidgetClass"
#   both refer to the Motif 'XmList' widget.
#
# parent
#   The Davinci widget ID of an existing widget.  If you are creating a new
#   top-level widget, no parent is required.
#
# resources
#   A Davinci struct containing key-value pairs for setting Xt resources.
#   You can reference other Davinci widgets in resources where it makes sense,
#   by using the Davinci widget ID.  See Xt/Motif reference manuals for a
#   complete list of resources.  Not all resource data types are supported at
#   this time, however all basic data types such as Cardinal, String, XmString,
#   XmStringTable, Widget, Boolean, Dimension (and subtypes such as
#   HorizontalDimension, etc), Short, Int, and so on are implemented.
#   Enumerated data types are less likely to be implemented completely as
#   there is no way to implement them in a generic fashion, however many
#   specific enumerated resources have been implemented based on usefulness.
#
# name
#   An arbitrary string for the widget name.  All Xt/Motif widgets must have
#   names, however they are not used by most widgets.  It's usually same to
#   leave this blank.  The primary use for this field is for setting the title
#   bar of top-level widgets.

##### topLevelShell widget

# You must create a top-level shell to hold other widgets before they can be
# displayed.  Here we create a top-level shell window with the title "Davinci"
# (shown on the window title bar).

top = gui.create("topLevelShell", name = "Davinci")

# Present a fileSelectionBox dialog, showing files matching the *.cub pattern.

fs = gui.create("fileSelectionBox", top, { pattern = "/u/jim/test/*.cub" })
gui.addcallback(fs, "ok", sprintf("fileSelectCallback(%d, \"ok\")", fs))
gui.addcallback(fs, "cancel", sprintf("fileSelectCallback(%d, \"cancel\")", fs))

##### Display

# Now that the widget is complete, display it to the user.  This step is
# necessary for each top-level widget (shells, dialogs, etc; anything that
# gets its own frame), but not for child widgets, which are realized
# automatically when the top level is realized.

gui.realize(top)

# Interactive from this point on.

verbose = 1
